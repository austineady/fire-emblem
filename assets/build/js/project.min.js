(function() {
  'use strict';

  // Base Global Obj
  var fe = {};
  window.fe = window.fe || fe;

  fe.characterSelected = false;
  fe.hudActive = false;
  fe.hudBottom = false;
  fe.selectorMoving = false;

  fe.heroSelected = undefined;
  fe.hud = undefined;
  fe.int = undefined;
  fe.registry = [];
  fe.tMap = [];

  var mvWorker = new Worker('assets/src/js/workers/move-worker.js');
  // Base Includes
  function _scale(item, s) {
    s = s ? s : scale;
    item.scaleX = s;
    item.scaleY = s;
  }
  
  function rowsToPixels(r) {
    // pixels per row
    var pxPerRow = yStart / 10;
  
    return pxPerRow * r;
  }
  
  function pixelsToRows(p) {
    return Math.floor(p / pxPerRow);
  }
  
  function colsToPixels(c) {
    // pixels per col
    var pxPerCol = xStart / 15;
  
    return pxPerCol * c;
  }
  
  function pixelsToCols(p) {
    return Math.floor(p / pxPerCol);
  }
  
  // http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object
  function isEmpty(obj) {
      return Object.keys(obj).length === 0 && obj.constructor === Object;
  }
  
  fe.render = function(stage, child) {
    if(child) {
      if(child.col !== undefined && child.row !== undefined) {
        child.x = colsToPixels(child.col);
        child.y = rowsToPixels(child.row);
      }
      if(child.index !== undefined) {
        stage.setChildIndex(child, 2);
      }
  
      stage.addChild(child);
    }
    stage.update();
    return;
  }
  
  fe.update = function(stage, child) {
    child.x = colsToPixels(child.col);
    child.y = rowsToPixels(child.row);
  
    stage.update();
    return;
  }
  
  fe.renderChild = function(container, child) {
    if(child.col !== undefined && child.row !== undefined) {
      child.x = colsToPixels(child.col - 1);
      child.y = rowsToPixels(child.row - 1);
    }
    if(child.index !== undefined) {
      container.setChildIndex(child, 2);
    }
  
    container.addChild(child);
    return;
  }
  
  // Functions
  
  function handleImageLoad(e) {
    console.log('Image Loaded:');
    console.log(e);
  }
  
  function handleImageError(e) {
    console.error('Image Error');
    console.log(e);
  }
  
  function drawCircle() {
    var circle = new createjs.Shape();
    // drawCircle(x, y, radius)
    circle.graphics.beginFill('DeepSkyBlue').drawCircle(0, 0, 50);
    circle.x = 100;
    circle.y = 100;
    //battle.addChild(circle);
    //renderStage();
  }
  
  function playSprite() {
    lyn.gotoAndPlay('start');
    createjs.Ticker.addEventListener("tick", function() {
      renderDisplay(lyn);
    });
  }
  
  function playSprite2() {
    if(brigand.currentFrame === 0) {
      brigand.gotoAndPlay('attack');
    } else {
      brigand.gotoAndPlay(brigand.currentFrame);
    }
    createjs.Ticker.addEventListener("tick", function() {
      if(brigand.currentFrame == 4) {
        brigand.y = -10;
        brigand.x = 80;
      } else if(brigand.currentFrame == 5) {
        brigand.x = 140;
      } else if(brigand.currentFrame == 6) {
        brigand.x = 190;
      } else if(brigand.currentFrame == 7 || brigand.currentFrame == 8) {
        brigand.x = 190;
        brigand.y = 15;
      } else if(brigand.currentFrame == 9) {
        brigand.x = 150;
        brigand.y = -5;
      } else if(brigand.currentFrame == 10) {
        brigand.x = 120;
        brigand.y = -15;
      } else if(brigand.currentFrame == 11) {
        brigand.x = 90;
        brigand.y = -15;
      } else {
        brigand.x = 70;
        brigand.y = 25;
      }
      renderDisplay(brigand);
    });
  }
  
  function stopSprite(action, obj) {
    sprite = obj ? obj : sprite;
    sprite.gotoAndStop(0);
    battle.update(lyn);
  }
  
  function stopSprite2() {
    brigand.gotoAndStop(brigand.currentFrame);
    renderDisplay(brigand);
  }
  
  function plusFrame(c) {
    var char = window[c];
    char.gotoAndStop(char.currentFrame);
    char.currentFrame = char.currentFrame + 1;
    char.gotoAndStop(char.currentFrame);
    renderDisplay(char);
  }
  
  function minusFrame(c) {
    var char = window[c];
    char.gotoAndStop(char.currentFrame);
    char.currentFrame = char.currentFrame - 1;
    char.gotoAndStop(char.currentFrame);
    renderDisplay(char);
  }
  
  function handleYOffsetChange(e, c) {
    window[c].y = e.value;
    renderDisplay(window[c]);
  }
  
  function handleXOffsetChange(e, c) {
    window[c].x = e.value;
    renderDisplay(window[c]);
  }
  
  function renderDisplay(c) {
    var fd = document.getElementById(c.wid + '-current-frame');
    var xd = document.getElementById(c.wid + '-x-offset');
    var yd = document.getElementById(c.wid + '-y-offset');
    fd.textContent = c.currentFrame;
    modifyLynX(c.currentFrame);
    if(xd.value.length === 0 && yd.value.length === 0) {
      xd.value = c.x;
      yd.value = c.y;
    }
    battle.update();
  }
  
  function modifyLynX(f) {
    switch(f) {
      case 4:
        lyn.x = 200;
        break;
      case 5:
        lyn.x = 170;
        break;
      case 6:
      case 7:
      case 8:
        lyn.x = 200;
        break;
      default:
        lyn.x = 230;
        break;
    }
    return;
  }
  
  fe.terrainMap = {
    't0': {
      tid: 0,
      type: '',
      avo: '--',
      def: '--',
      regen: 0,
      collide: true
    },
    't1': {
      tid: 1,
      type: 'Plain',
      avo: 20,
      def: 1,
      regen: 0,
      collide: false
    },
    't2': {
      tid: 2,
      type: 'Forest',
      avo: 20,
      def: 1,
      regen: 0,
      collide: false
    },
    't3': {
      tid: 3,
      type: 'Sand',
      avo: 5,
      def: '--',
      regen: 0,
      collide: false
    },
    't4': {
      tid: 4,
      type: 'Mountain',
      avo: 30,
      def: 1,
      regen: 0,
      collide: false
    },
    't5': {
      tid: 5,
      type: 'Peak',
      avo: 40,
      def: 2,
      regen: 0,
      collide: false
    },
    't6': {
      tid: 6,
      type: 'Sea',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't7': {
      tid: 7,
      type: 'Fortress',
      avo: 40,
      def: 2,
      regen: 20,
      collide: false
    },
    't8': {
      tid: 8,
      type: 'Village',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't9': {
      tid: 9,
      type: 'Pillar',
      avo: 20,
      def: 1,
      regen: 0,
      collide: false
    },
    't10': {
      tid: 10,
      type: 'Throne',
      avo: 20,
      def: 2,
      regen: 0,
      collide: false
    },
    't11': {
      tid: 11,
      type: 'Armory',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't12': {
      tid: 12,
      type: 'Vendor',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't13': {
      tid: 13,
      type: 'Arena',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't14': {
      tid: 14,
      type: 'House',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't15': {
      tid: 15,
      type: 'Inn',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't16': {
      tid: 16,
      type: 'Ruins',
      avo: 10,
      def: '--',
      regen: 0,
      collide: false
    },
    't1.1': {
      tid: 1.1,
      type: 'Barrel',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.2': {
      tid: 1.2,
      type: 'Brace',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.3': {
      tid: 1.3,
      type: 'Bridge',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.4': {
      tid: 1.4,
      type: 'Bone',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.5': {
      tid: 1.5,
      type: 'Chest',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.6': {
      tid: 1.6,
      type: 'Door',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.7': {
      tid: 1.7,
      type: 'Deck',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.8': {
      tid: 1.8,
      type: 'Fence',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.9': {
      tid: 1.9,
      type: 'Floor',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.10': {
      tid: 1.10,
      type: 'Road',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.11': {
      tid: 1.11,
      type: 'River',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.12': {
      tid: 1.12,
      type: 'Stairs',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.13': {
      tid: 1.13,
      type: 'Thicket',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't1.14': {
      tid: 1.14,
      type: 'Wall',
      avo: '--',
      def: '--',
      regen: 0,
      collide: false
    },
    't0.1': {
      tid: 0.1,
      type: 'Cliff',
      avo: '--',
      def: '--',
      regen: 0,
      collide: true
    }
  }
  
  function handleRectClick(rect, e, c) {
    var targetCol = rect.col;
    var targetRow = rect.row;
  
    var colDiff = targetCol - hero.col;
    var rowDiff = targetRow - hero.row;
  
    handleMovement(colDiff, rowDiff, c);
  }
  
  function createMoveMap(c) {
    // Current character coords
    var col = c.col - 1;
    var row = c.row - 1;
    var mv = c.mv;
    var cCalc = col * pxPerCol;
    var rCalc = row * pxPerRow;
    var cw = main.canvas.clientWidth;
    var ch = main.canvas.clientHeight;
    var matrixArr = [];
    var newMatrix = [];
    var atkMatrix = [];
    var arrCache = [];
    var mvTotal = mv + 1;
  
    for(var i=0; i <= mvTotal; i++) {
      for(var idx=0; idx<= mvTotal; idx++) {
        if(idx + i <= mvTotal && idx + i !== 0) {
          matrixArr.push([idx, i]);
        }
      }
    }
  
    matrixArr.forEach(function(item) {
      var newItem = [];
      var cacheString = '';
      newItem[0] = (col + item[0]) * pxPerCol;
      newItem[1] = (row + item[1]) * pxPerRow;
      cacheString = newItem[0] + ', ' + newItem[1];
      if(arrCache.indexOf(cacheString) === -1 && newItem[0] <= cw && newItem[0] >= 0 && newItem[1] <= ch) {
        arrCache.push(cacheString);
        if(item[0] + item[1] < mvTotal) {
          newMatrix.push(newItem);
        } else {
          atkMatrix.push(newItem);
        }
      }
      newItem = [];
      newItem[0] = (col - item[0]) * pxPerCol;
      newItem[1] = (row - item[1]) * pxPerRow;
      cacheString = newItem[0] + ', ' + newItem[1];
      if(arrCache.indexOf(cacheString) === -1 && newItem[0] <= cw && newItem[0] >= 0 && newItem[1] <= ch) {
        arrCache.push(cacheString);
        if(item[0] + item[1] < mvTotal) {
          newMatrix.push(newItem);
        } else {
          atkMatrix.push(newItem);
        }
      }
      newItem = [];
      newItem[0] = (col + item[0]) * pxPerCol;
      newItem[1] = (row - item[1]) * pxPerRow;
      cacheString = newItem[0] + ', ' + newItem[1];
      if(arrCache.indexOf(cacheString) === -1 && newItem[0] <= cw && newItem[0] >= 0 && newItem[1] <= ch) {
        arrCache.push(cacheString);
        if(item[0] + item[1] < mvTotal) {
          newMatrix.push(newItem);
        } else {
          atkMatrix.push(newItem);
        }
      }
      newItem = [];
      newItem[0] = (col - item[0]) * pxPerCol;
      newItem[1] = (row + item[1]) * pxPerRow;
      cacheString = newItem[0] + ', ' + newItem[1];
      if(arrCache.indexOf(cacheString) === -1 && newItem[0] <= cw && newItem[0] >= 0 && newItem[1] <= ch) {
        arrCache.push(cacheString);
        if(item[0] + item[1] < mvTotal) {
          newMatrix.push(newItem);
        } else {
          atkMatrix.push(newItem);
        }
      }
      return;
    })
    //console.log(newMatrix);
    //console.log(atkMatrix);
    moveCache = newMatrix;
  
    drawMoveRects(newMatrix, c);
    drawAtkRects(atkMatrix, c);
    fe.characterSelected = true;
  }
  
  function drawMoveRects(arr, c) {
    fe.moveContainer = new createjs.Container();
    arr.forEach(function(coord) {
      var rect = new createjs.Shape();
      rect.col = coord[0] / pxPerCol + 1;
      rect.row = coord[1] / pxPerRow + 1;
      rect.graphics.beginFill('rgba(92, 165, 225, .6)').drawRect(coord[0], coord[1], pxPerCol - 1, pxPerRow - 1);
      rect.empty = true;
      register(rect);
      fe.moveContainer.addChild(rect);
    });
    main.addChild(fe.moveContainer);
    main.setChildIndex(fe.moveContainer, 1);
    main.update();
  }
  
  function drawAtkRects(arr, c) {
    fe.moveContainer = fe.moveContainer ? fe.moveContainer : new createjs.Container();
    arr.forEach(function(coord) {
      var rect = new createjs.Shape();
      rect.col = coord[0] / pxPerCol;
      rect.row = coord[1] / pxPerRow;
      rect.graphics.beginFill('rgba(244, 67, 55, .6)').drawRect(coord[0], coord[1], pxPerCol - 1, pxPerRow - 1);
      rect.addEventListener('click', function(e) {
        handleRectClick(rect, e, c);
      });
      fe.moveContainer.addChild(rect);
    });
    main.addChild(fe.moveContainer);
    main.setChildIndex(fe.moveContainer, 1);
    main.update();
  }
  
  function removeMoveMap() {
    fe.moveContainer.children.forEach(function(child) {
      unregister(child);
    });
    main.removeChild(fe.moveContainer);
    return;
  }
  
  function resetStage() {
    fe.characterSelected = false;
    fe.hoverSelect = fe.heroSelected;
    fe.heroSelected = undefined;
    hero = {};
    fe.render(main);
  }
  
  function calculateMoveSelect() {
    var hero = fe.heroSelected;
    var colMem = hero.col;
    var rowMem = hero.row;
    if(fe.registry[selector.row][selector.col].requestMove(c)) {
      unregister(hero);
      hero.col = selector.col;
      hero.row = selector.row;
      removeMoveMap();
      register(hero);
      hero.getMoveMatrix(hero.col, hero.row);
      fe.render(main, hero);
      resetStage();
    }
  }
  
  function handleMovement(x, y, c) {
    if(x !== 0) {
      moveX(x, c);
    }
    if(y !== 0) {
      moveY(y, c);
    }
  }
  
  function moveX(x, c) {
    if(x > 0) {
      // move right
      for(var i=1; i<=x; i++) {
        c.col += i;
        fe.update(main, c);
      }
    } else {
      // move left
      for(var i = 1; i <= Math.abs(x); i++) {
        c.col -= i;
        fe.update(main, c);
      }
    }
    return;
  }
  
  function moveY(y, c) {
    if(y > 0) {
      // move down
      for(var i=1; i<=y; i++) {
        c.row += i;
        fe.update(main, c);
      }
    } else {
      // move up
      for(var i = 1; i <= Math.abs(y); i++) {
        c.row -= i;
        fe.update(main, c);
      }
    }
    return;
  }
  
  function createSelector() {
    var cw = main.canvas.clientWidth;
    var ch = main.canvas.clientHeight;
    var img = new Image();
    img.src = 'assets/images/overworld/overworld-select.png';
    img.onload = function() {
      var data = {
        row: 8,
        col: 13,
        images: [img],
        frames: {width: 24, height: 24, count: 2, regX: 0, regY: 0}
      }
      var ss = new createjs.SpriteSheet(data);
      selector = new createjs.Sprite(ss);
      selector.row = data.row;
      selector.col = data.col;
      _scale(selector, scaleB);
      fe.render(main, selector);
      selector.gotoAndPlay(0);
      fe.arrowStart = [selector.x, selector.y];
      bindSelector();
    };
  }
  
  function bindSelector() {
    bg.addEventListener('click', handleStageClick);
    document.addEventListener('keydown', function(e) {
      switch(e.keyCode) {
        case 38:
          // Arrow Up
          if(selector.row - 1 >= 0) {
            selector.row -= 1;
          } else {
            selector.row = selector.row;
          }
          var arrowY = selector.row;
          var arrowX = selector.col;
          fe.render(main, selector);
          //renderArrow(arrowX, arrowY, 0);
          break;
        case 39:
          // Arrow Right
          if(selector.col + 1 <= totalCols) {
            selector.col += 1;
          } else {
            selector.col = selector.col;
          }
          var arrowY = selector.row;
          var arrowX = selector.col;
          fe.render(main, selector);
          //renderArrow(arrowX, arrowY, 90);
          break;
        case 40:
          // Arrow Down
          if(selector.row + 1 <= totalRows) {
            selector.row += 1;
          } else {
            selector.row = selector.row;
          }
          var arrowY = selector.row;
          var arrowX = selector.col;
          fe.render(main, selector);
          //renderArrow(arrowX, arrowY, 180);
          break;
        case 37:
          // Arrow Left
          selector.row = selector.row;
          if(selector.col - 1 >= 0) {
            selector.col -= 1;
          } else {
            selector.col = selector.col;
          }
          var arrowY = selector.row;
          var arrowX = selector.col;
          fe.render(main, selector);
          //renderArrow(arrowX, arrowY, 270);
          break;
        case 32:
          // Spacebar
          if(fe.registry[selector.row][selector.col] !== undefined && !fe.characterSelected) {
            fe.heroSelected = fe.registry[selector.row][selector.col];
            console.log("Hero Selected: ");
            console.log(fe.heroSelected);
            drawMoveRects(fe.heroSelected.moveMap[0], fe.heroSelected);
            drawAtkRects(fe.heroSelected.moveMap[1], fe.heroSelected);
            fe.characterSelected = true;
          } else if(fe.characterSelected && fe.hoverSelect === fe.heroSelected) {
            removeMoveMap();
          } else if(fe.characterSelected && fe.heroSelected !== undefined) {
            console.log("Space Bar Pressed");
            calculateMoveSelect();
          }
          break;
      }
      handleSelector();
      _scale(selector, scaleB);
      fe.render(main, selector);
      selector.gotoAndPlay(0);
    })
  }
  
  function handleStageClick(e) {
    selector.col = pixelsToCols(e.stageX);
    selector.row = pixelsToRows(e.stageY);
    fe.update(main, selector);
    handleSelector();
  }
  
  function handleSelector() {
    if(selector.row < totalRows / 2 && !fe.hudBottom) {
      fe.hudBottom = true;
    } else if(selector.row >= totalRows / 2 && fe.hudBottom) {
      fe.hudBottom = false;
    }
    if(fe.registry[selector.row][selector.col] !== undefined) {
      fe.hoverSelect = fe.registry[selector.row][selector.col];
      console.log("Select Hover Event:");
      console.log(fe.hoverSelect);
      if(fe.hoverSelect.hud) {
        console.log("Hud Activated");
        if(!fe.hudActive) {
          displayHud(fe.hoverSelect);
        }
      }
    } else {
      fe.hoverSelect = undefined;
      if(fe.hudActive) {
        console.log("Hud Deactivated");
        removeHud();
      }
    }
    return;
  }
  
  function Hud(c) {
    // rgba(182, 209, 255, .7)
    var g = new createjs.Graphics().setStrokeStyle(1).beginStroke('rgba(175, 170, 146, 1.00)').beginFill('rgba(255, 255, 255, .75)').drawRoundRect(0, 0, 100, 36, 2, 2, 2, 2);
    var hudBg = new createjs.Shape(g);
    hudBg.shadow = new createjs.Shadow('rgba(0, 0, 0, .6)', 1, 1, 1);
  
    var hudHpLabel = new createjs.Text('HP', '700 11px Quicksand, sans-serif', '#fff');
    hudHpLabel.shadow = new createjs.Shadow('#000', 0, 0, 5);
    hudHpLabel.x = 40;
    hudHpLabel.y = 14;
  
    var hudHp = new createjs.Text(c.hp, '500 10px Quicksand, sans-serif', 'rgba(40, 44, 52, 1.00)');
    hudHp.x = 60;
    hudHp.y = 15;
  
    var hudHpMax = new createjs.Text('/ '+c.hpMax, '500 10px Quicksand, sans-serif', 'rgba(40, 44, 52, 1.00)');
    hudHpMax.x = 73;
    hudHpMax.y = 15;
  
    var hudHealthContainer = new createjs.Container();
    hudHealthContainer.x = 40;
    hudHealthContainer.y = 28;
    var hudHealthWidth = 54;
    var hudHealthHeight = 4;
    var hudHealthRadius = 2;
  
    var hudHealthBar = new createjs.Graphics().beginFill('rgba(153, 135, 61, 1.00)').drawRoundRect(0, 0, hudHealthWidth, 4, hudHealthRadius, hudHealthRadius, hudHealthRadius, hudHealthRadius);
    hudHealthBar = new createjs.Shape(hudHealthBar);
    var hudHealth = new createjs.Graphics().beginFill('rgba(225, 204, 104, 1.00)').drawRoundRect(1, 1, hudHealthWidth - 2, hudHealthHeight - 2, hudHealthRadius, hudHealthRadius, hudHealthRadius, hudHealthRadius);
    hudHealth = new createjs.Shape(hudHealth);
  
    hudHealthContainer.addChild(hudHealthBar);
    hudHealthContainer.setChildIndex(hudHealthBar, 5);
    hudHealthContainer.addChild(hudHealth);
    hudHealthContainer.setChildIndex(hudHealth, 6);
  
    var hudName = c.hud.nameDisplay !== undefined ? new createjs.Text(c.hud.nameDisplay, '500 10px Quicksand, sans-serif', 'rgba(40, 44, 52, 1.00)') : '';
    hudName.x = c.hud.nameX || 55;
    hudName.y = c.hud.nameY || 2;
  
    var hudImg = c.hud.mugshot !== undefined ? Mugshot(c.hud.mugshot) : '';
    hudImg.x = c.hud.imgX || 3;
    hudImg.y = c.hud.imgY || 3;
    if(hudImg === '') {
      console.error('Mugshot was invalid. Check the sprite sheet path');
    }
  
    var hud = new createjs.Container();
    hud.x = pxPerCol / 2;
    hud.y = fe.hudBottom ? pxPerRow * (totalRows - 2) - pxPerRow / 2 : pxPerRow / 2;
    hud.addChild(hudBg);
    hud.addChild(hudImg);
    hud.addChild(hudHpLabel);
    hud.addChild(hudHp);
    hud.addChild(hudHpMax);
    hud.addChild(hudName);
    hud.addChild(hudHealthContainer);
    _scale(hud);
    return hud;
  }
  
  function displayHud(c) {
    fe.hud = new Hud(c);
    fe.render(main, fe.hud);
    fe.hudActive = true;
  }
  
  function removeHud() {
    main.removeChild(fe.hud);
    fe.hudActive = false;
    fe.render(main);
  }
  
  // Terrain Map
  // 0 unwalkable
  // 1 plains
  // 2 woods
  // 3 sand
  // 4 mountains
  // 5 peak
  // 6 sea
  // 7 fortress
  // 8 village
  // 9 pillar
  // 10 throne
  // 11 Armory
  // 12 Vendor
  // 13 Arena
  // 14 House
  // 15 Inn
  // 16 Ruins
  // Semantic Locations
  // 1.1 Barrel
  // 1.2 Brace
  // 1.3 Bridge
  // 1.4 Bone
  // 1.5 Chest
  // 1.6 Door
  // 1.7 Deck
  // 1.8 Fence
  // 1.9 Floor
  // 1.10 Road
  // 1.11 River
  // 1.12 Stairs
  // 1.13 Thicket
  // 1.14 Wall
  // 0.1 Cliff
  
  var maps = {
    level0: {
      background: 'assets/images/background/bg-map-1.png',
      terrain: [
        // Row 1
        [4, 4, 0, 0, 0, 1, 1, 2, 1, 4, 4, 5, 5, 5, 5],
        // Row 2
        [1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 4, 4, 5, 5],
        // Row 3
        [1, 1, 0, 7, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4],
        // Row 4
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        // Row 5
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        // Row 6
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        // Row 7
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        // Row 8
        [0.1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
        // Row 9
        [0.1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.1, 2, 1],
        // Row 10
        [0.1, 1, 2, 1, 1, 1, 1, 1, 1, 0.1, 0.1, 0.1, 0.1, 1, 14]
      ]
    }
  };
  


  // Hero Includes
  // Needed Variables
  var brigand = new Brigand(),
      lyn = new Lyn();
  
  function createBattleCharacters() {
  
    createBattleStage();
  }
  
  function createBattleStage() {
    var be = document.getElementById('battle');
    be.width = xStartB;
    be.height = yStartB;
    battle = new createjs.Stage('battle');
  
    buildImage(lyn.battle.src, lyn.battle, 'start', createSpriteAnimation);
    buildImage(brigand.ss, brigand.battle, 'attack', createSpriteAnimation);
  }
  
  function createSpriteAnimation(ss, action, data) {
    window[data.wid] = new createjs.Sprite(ss);
    window[data.wid].wid = data.wid;
    window[data.wid].mv = data.mv;
    var sprite = window[data.wid];
    sprite.y = data.posY ? data.posY : 0;
    sprite.x = data.posX ? data.posX : 0;
    _scale(sprite, scaleB);
    battle.addChild(sprite);
    renderDisplay(sprite);
  
    sprite.gotoAndStop(0);
  }
  
  'use strict';
  
  function Lyn(col, row) {
    this.row = row || 8;
    this.col = col || 13;
    this.mv = 5;
    this.hpMax = 21;
    this.hp = this.hpMax;
    this.lvl = 1;
    this.builder = function(col, row) {
      return new Lyn(col, row);
    },
    this.src = 'assets/images/overworld/overworld-characters-clean.png';
    // image to use
    this.images = [];
    // width, height, count(optional), registration x, registration y
    this.frames = [
      // x, y, width, height, imageIndex, regX, regY
      [189, 171, 16, 16],
      [189, 203, 16, 16],
      [189, 235, 16, 16]
    ];
    this.animations = {
      'idle': {
        frames: [0, 0, 1, 2, 2, 1, 0, 0],
        next: 'idle'
      }
    };
    this.hud = {
      nameDisplay: "Lyn",
      mugshot: [352, 348, 32, 32]
    },
    this.battle = {
      wid: 'lyn',
      posY: 40,
      posX: 230,
      row: 9,
      col: 15,
      mv: 3,
      src: 'assets/images/animations/hero/lyn-loop.png',
      // image to use
      images: [],
      // width, height, count(optional), registration x, registration y
      frames: {width:64, height:64, count:22, regX:0, regY:0},
      animations: {
        idle: 0,
        start: {
          frames: [0, 2],
          next: 'hold',
          speed: .3
        },
        hold: {
          frames: 3,
          next: 'strike',
          speed: .1
        },
        strike: {
          frames: [4, 6],
          next: 'wait',
          speed: .5
        },
        wait: {
          frames: 7,
          next: 'jump',
          speed: .1
        },
        jump: {
          frames: 8,
          next: 'air',
          speed: .6
        },
        air: {
          frames: 9,
          next: 'land',
          speed: .2
        },
        land: {
          frames: [10, 13],
          next: 'sheathe',
          speed: .4
        },
        sheathe: {
          frames: [14, 20],
          next: 'end',
          speed: .3
        },
        end: {
          frames: [21, 22],
          next: 'idle',
          speed: .1
        }
      }
    }
  };
  
  function Brigand(col, row) {
    this.wid = 'brigand';
    this.row = row || 2;
    this.col = col || 3;
    this.mv = 5;
    this.hpMax = 21;
    this.hp = this.hpMax;
    this.lvl = 1;
    this.builder = function(col, row) {
      return new Brigand(col, row);
    }
    this.src = 'assets/images/animations/enemy/brigand-clean.png';
    this.images = [];
    this.frames = [
      [0, 230, 17, 17],
      [23, 230, 17, 17],
      [46, 230, 17, 17]
    ];
    this.animations = {
      'idle': {
        frames: [0, 1, 2, 2, 2, 1, 0, 0],
        next: 'idle'
      }
    };
    this.hud = {
      nameDisplay: "Brigand",
      nameX: 45,
      mugshot: [608, 2028, 32, 32]
    },
    this.battle = {
      wid: 'brigand',
      posX: 150,
      posY: 25,
      images: [],
      frames: [
        [3, 0, 38, 54],
        [46, 0, 38, 54],
        [94, 0, 36, 54],
        [140, 0, 36, 54],
        [188, 0, 38, 74],
        [236, 0, 41, 59],
        [281, 0, 41, 59],
        [326, 0, 43, 56],
        [374, 0, 41, 56],
        [418, 0, 42, 56],
        [0, 60, 31, 59],
        [41, 60, 26, 54]
      ],
      animations: {
        idle: 0,
        attack: [0, 1, 'twist', .4],
        twist: [1, 4, 'jump', .7],
        jump: [5, 5, 'strike', .7],
        strike: [6, 7, 'retreat', .5],
        retreat: [8, 9, 'land', .4],
        land: [10, 11, 'idle', .4]
      }
    }
  };
  
  

  var main = fe.main = {},
      battle = fe.battle = {},
      hero = fe.hero = {},
      bg = fe.bg = {},
      metrics = fe.metrics = {},
      selector = fe.selector = {},
      arrowHead = fe.arrowHead = {},
      Mugshot = undefined;

  var totalRows = fe.totalRows = 10,
      totalCols = fe.totalCols = 15,
      canvasWidth = fe.canvasWidth = 240,
      ratio = fe.metrics.ratio = 1.5,
      scale = fe.metrics.scale = window.innerWidth <= 500 ? window.innerWidth / canvasWidth : 500 / canvasWidth,
      scaleB = fe.metrics.scaleB = 1.5;

  var xStartB = fe.metrics.xStartB = canvasWidth * scaleB,
      yStartB = fe.metrics.yStartB = xStartB / ratio,
      xStart = fe.metrics.xStart = canvasWidth * scale,
      yStart = fe.metrics.yStart = xStart / ratio,
      pxPerCol = fe.pxPerCol = xStart / totalCols,
      pxPerRow = fe.pxPerRow = yStart / totalRows;

  var mainBg = 'assets/images/background/bg-map-1.png';


  document.onload = createStage();

  function createStage() {
    var me = document.getElementById('main');
    me.width = xStart;
    me.height = yStart;
    main = new createjs.Stage('main');
    createTiles(maps.level0.terrain);
    setBackground(maps.level0.background);
    createOverworldCharacters();
    createOverworldSheets();
    createSelector();
    owDebug();
    window.setTimeout(handleSelector, 100);
    createjs.Ticker.addEventListener("tick", function (event) {
        // Actions carried out each tick (aka frame)
        fe.render(main);
        if (!event.paused) {
            // Actions carried out when the Ticker is not paused.
        }
    });
    createjs.Ticker.framerate = 4;
  };

  function Tile(col, row, key) {
    var obj = fe.terrainMap[key];
    this.col = col;
    this.row = row;
    this.tid = obj.tid;
    this.type = obj.type;
    this.avo = obj.avo;
    this.def = obj.def;
    this.regen = obj.regen;
    this.collide = obj.collide;
    this.character = null;
    this.canMoveTo = false;
    this.canAttack = false;
    this.addCharacter = function(c) {
      if(this.character === null) {
        this.character = c;
      } else {
        console.error('There is already a character in that tile');
      }
    }
    this.removeCharacter = function() {
      this.character = {};
    }
    this.requestMove = function(c) {
      var self = this;
      if(!this.collide && this.canMoveTo && !this.canAttack && this.character === null) {
        this.character = c;
        this.canMoveTo = false;
        return true;
      } else {
        return false;
      }
    }
  }

  function createTiles(tmap) {
    for(var i = 0; i < 10; i++) {
      var rowArray = [];
      var row = tmap[i];
      for(var idx = 0; idx < 15; idx++) {
        var col = row[idx];
        var tile = new Tile(idx, i, ('t' + col));
        rowArray.push(tile);
      }
      fe.registry.push(rowArray);
    }
  }

  function owDebug(x, y, col, row) {
    var paramList = [x, y, col, row];
    var idList = ['selector-x', 'selector-y', 'selector-col', 'selector-row'];
    for(var i=0;i<idList.length;i++) {
      var el = document.getElementById(idList[i]);
      el.textContent = paramList[i];
    }
  }

  function createOverworldCharacters() {
    buildSheet(lyn).then(function(ss) {
      createOverworld(ss, 'idle', lyn);
    }, function(error) {
      console.error(error);
    })
    buildSheet(brigand).then(function(ss) {
      createOverworld(ss, 'idle', brigand);
    }, function(error) {
      console.error(error);
    })
  }

  function createOverworldSheets() {
    var mugImg = new Image();
    mugImg.src = 'assets/images/mugshots/mugshot-conversation-map-clean.png';
    mugImg.onload = function() {
      Mugshot = function(frames) {
        var mugSS = new createjs.SpriteSheet({
          images: new Array(mugImg),
          frames: [
            frames
          ]
        });
        var mugSprite = new createjs.Sprite(mugSS);
        return mugSprite;
      };
      return;
    }
  }

  function register(c) {
    fe.registry[c.row][c.col].addCharacter(c);
    console.log('Character Added:');
    console.log(fe.registry[c.row][c.col]);
    return;
  }

  function unregister(c) {
    fe.registry[c.row][c.col].removeCharacter(c);
    return;
  }

  function registry(row, col) {
    try {
      return fe.registry[row][col];
    } catch(e) {
      console.error('Error in function registry');
    }
  }

  function setBackground(path) {
    bg = new createjs.Bitmap(path);
    _scale(bg);
    main.addChild(bg);
    main.setChildIndex(bg, -1);
  }

  function buildSheet(character) {
    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.src = character.src;
      img.onload = function() {
        character.images.push(img);
        var ss = new createjs.SpriteSheet(character);
        resolve(ss);
      };
      img.onerror = function(err) {
        reject(Error(err));
      }
    })
  }

  function buildImage(path, character, action, cb) {
    var img = new Image();
    img.src = path;
    img.onload = function() {
      createSpriteSheet(img, character, action, cb);
    };
  }

  function createSpriteSheet(img, character, action, cb) {
    character.images.push(img);
    var ss = new createjs.SpriteSheet(character);
    cb(ss, action, character);
  }

  function createOverworld(ss, action, character) {
    character.sheet = ss;
    character.sprite = new createjs.Sprite(ss, action);
    bindCharacterProps(character.sprite, character);
    character.sprite.index = 2;
    _scale(character.sprite);
    register(character.sprite);
    fe.render(main, character.sprite);

    character.sprite.gotoAndPlay('idle');
    character.sprite.getMoveMatrix(character.sprite.col, character.sprite.row);
  } // end createOverworld

  function bindCharacterProps(cs, c) {
    cs.getMoveMatrix = function(col, row) {
      mvWorker.postMessage({
        'tMap': fe.tMap,
        'canvasHeight': main.canvas.clientHeight,
        'canvasWidth': main.canvas.clientWidth,
        'totalCols': totalCols,
        'totalRows': totalRows,
        'mv': c.mv,
        'col': col,
        'row': row,
        'atk': 1
      });

      mvWorker.onmessage = function(e) {
        fe.registry[e.data[3]][e.data[2]].character.moveMap = [e.data[0], e.data[1]];
        console.log('Move Map Added: ');
        console.log(fe.registry[e.data[3]][e.data[2]]);
      }
    }
    cs.hp = c.hp;
    cs.hpMax = c.hpMax;
    cs.lvl = c.lvl;
    cs.cid = c.wid;
    cs.mv = c.mv;
    cs.builder = c.builder;
    cs.col = c.col;
    cs.row = c.row;
    cs.hud = c.hud;
    return;
  }

  function renderArrow(x, y, rot) {
    var img = new Image();
    img.src = 'assets/images/overworld/arrow-head.png';
    img.onload = function() {
      var data = {
        images: [img],
        frames: {width: 16, height: 16, count: 1, regX: 0, regY: 0}
      }
      var ss = new createjs.SpriteSheet(data);
      var arrow = new createjs.Sprite(ss);
      _scale(arrow);
      if(!arrowHead.length) {
        arrowHead = arrow;
      }
      if(arrowHead.col === undefined) {
        arrowHead.col = selector.col;
      } else {
        arrow.col = arrowHead.col + x;
      }

      if(arrowHead.row === undefined) {
        arrowHead.row = selector.row;
      } else {
        arrow.row = arrowHead.row + y;
      }
      console.log(arrow);
      arrow.col = selector.col;
      arrow.row = selector.row;
      arrow.index = 3;
      arrow.rotation = rot;
      fe.renderChild(main, arrow);
      fe.render(main);
      arrow.gotoAndPlay(0);
    }
  }
})();
